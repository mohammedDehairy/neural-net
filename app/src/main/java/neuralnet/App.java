/*
 * This source file was generated by the Gradle 'init' task
 */
package neuralnet;

import java.io.BufferedReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Collections;
import java.util.List;

public class App {

    public static void main(String[] args) throws IOException {
        MultiLayerPerceptron mlp = new MultiLayerPerceptron(2, new int[] { 16, 16, 1 });
        Value[][] train = buildTrainingData();
        Value[] actual = buildLabelOutput();
        double learningRate = -0.01;

        for (int x = 0; x < 1000; x++) {
            Value[] pred = new Value[actual.length];
            Value netLoss = new Value(0.0, "netLoss");

            for (int i = 0; i < train.length; i++) {
                pred[i] = mlp.activate(train[i])[0];
                Value curLoss1 = pred[i].subtract(actual[i], "loss1");
                Value curLoss2 = pred[i].subtract(actual[i], "loss2");
                Value curLoss = curLoss1.multiply(curLoss2, "lossSquared");

                netLoss = netLoss.add(curLoss, "netLoss");
            }

            List<Value> parameters = mlp.parameters();
            for (Value parameter: parameters) {
                parameter.setGradient(0);
            }

            List<Value> topologicalOrder = netLoss.getTopologicalOrder();
            Collections.reverse(topologicalOrder);

            netLoss.setGradient(1.0);
            for (Value value: topologicalOrder) {
                value.computeParentGradient();
            }

            for (Value parameter: parameters) {
                double value = parameter.getValue();
                value += learningRate * parameter.getGradient();
                parameter.setValue(value);
            }

            System.out.println("iteration: " + x);

            if (x == 999) {
                writePredictions(pred, actual);
            }
        }
    }

    private static Value[][] buildTrainingData() throws IOException {
        Value[][] train = new Value[100][2];
        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
        InputStream is = classLoader.getResourceAsStream("train.csv");
        InputStreamReader streamReader = new InputStreamReader(is);
        BufferedReader br = new BufferedReader(streamReader);
        int i = 0;
        for (String line; (line = br.readLine()) != null; i++) {
            String[] row = line.split(",");
            double x1 = Double.parseDouble(row[1]);
            double x2 = Double.parseDouble(row[2]);
            train[i] = new Value[] { new Value(x1, "x1"), new Value(x2, "x2") };
        }
        return train;
    }

    private static Value[] buildLabelOutput() throws IOException {
        Value[] actualLabels = new Value[100];
        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
        InputStream inputStream = classLoader.getResourceAsStream("train.csv");
        InputStreamReader inputStreamReader = new InputStreamReader(inputStream);
        BufferedReader bufferedReader = new BufferedReader(inputStreamReader);
        int index = 0;
        for (String line; (line = bufferedReader.readLine()) != null; index++) {
            String[] row = line.split(",");
            double value = Double.parseDouble(row[3]);
            actualLabels[index] = new Value(value, "y");
        }
        return actualLabels;
    }

    private static void writePredictions(Value[] pred, Value[] labels) throws IOException {
        Path resources = Paths.get(App.class.getResource("/").getPath());
        String filePath = resources.toString() + "/predictions.txt";
        Files.deleteIfExists(Paths.get(filePath));
        try(FileWriter fileWriter = new FileWriter(filePath)) {
            for (int i = 0; i < pred.length; i++) {
                fileWriter.write(pred[i].getValue() + ", " + labels[i].getValue() + "\n");
            }
        }
    
    }
}
